using System.Diagnostics.Metrics;
using System.Reflection;
using System.Text;

namespace Homework_8
{
    enum MenuItem
    {
        Task = '!'
    }

    public class Program
    {
        public static int[] GenerateRandomNumberArr(int ArrSize)
        {
            const int start = 0, end = 100;
            var arr = new int[ArrSize];
            var rnd = new Random();

            for (int i = 0; i < ArrSize; i++)
            {
                arr[i] = rnd.Next(start, end);
            }

            return arr;
        }

        public static void ShowArr(int[] arr)
        {
            foreach (var item in arr)
            {
                Console.Write($"{item} \t");
            }
            Console.WriteLine();
        }

        public static void BubbleSortSimple(int[] arr) // функция Пузырькового сортирования(простая) в которой передан размер и содержание массива
        {
            int counter = 0; // счетчик итераций внешнего цикла (пока просто 0)

            for (int i = 0; i < arr.Length; i++) // задает параметры внешнего цикла что i = 0; i < должна быть меньше значения нашего массива в данном случае (30), и что i увеличивается на 1 до тех пор пока не достигнет значения нашего массива
            {
                counter++; // увеличивает количетсво итераций на 1 когда отрабатывает внешний цикл

                for (int j = 0; j < arr.Length - i - 1; j++) // задает параметры внутреннего цикла что j = 0; j < должна быть меньше значения нашего массива в данном случае (30), - i что бы не проверяло уже отсортированные значения - 1 потому что последнее значение не с чем сравнивать (самое большое), и что j увеличивается на 1 до тех пор пока не достигнет значения нашего массива
                {
                    if (arr[j] > arr[j + 1]) // если j больше j + 1 тоесть если какое-то значение в массиве больше следующего значения в массиве. Например второе значение в массиве 19 больше третьего значения в массиве 9 - да, тогда заходим во внутрь, если значение j меньше значения j + 1 то тогда пропускаем и увеличиваем j на 1 и опять проверяем
                    {
                        var temp = arr[j]; // в переменную temp записываем переменную j с значением например 10 в массиве
                        arr[j] = arr[j + 1]; // мы пишем что переменная j в которой хранится значение (10) равна переменной j + 1 в которой хранится значение (8) перезаписываем j и теперь она равна переменной j + 1 в которой хранится значение (8)
                        arr[j + 1] = temp; // теперь тут мы пишем что j + 1 (8) равна temp а в переменной temp хранится значение j (10) соответсвенно перезаписываем значение перемнной temp в переменную j + 1 и теперь j + 1 равна (10) 

                        //var temp = arr[j + 1];
                        //arr[j + 1] = arr[j]; ---тоже самое только наоборот // также проверил работает ли этот алгоритм (Пузырьковый) с отрицательными и положительными значениями - работает
                        //arr[j] = temp;
                    }
                }
            }
            //Console.WriteLine($"BubbleSortSimple: {counter}"); // показывает сколько было итераций внешнего цикла
        }

        public static void BubbleSortOptimized(int[] arr) // функция Пузырькового сортирования (оптимизированная) в которой передан размер и содержание массива
        {
            int counter = 0; // счетчик итераций внешнего цикла (пока просто 0)

            for (int i = 0; i < arr.Length; i++) // задает параметры внешнего цикла что i = 0; i < должна быть меньше значения нашего массива в данном случае (30), и что i увеличивается на 1 до тех пор пока не достигнет значения нашего массива
            {
                bool swaped = false; // хранит состояние менялось ли значение или нет (отсортирован ли массив или нет)
                counter++; // увеличивает количетсво итераций на 1 когда отрабатывает внешний цикл

                for (int j = 0; j < arr.Length - i - 1; j++) // задает параметры внутреннего цикла что j = 0; j < должна быть меньше значения нашего массива в данном случае (30), - i что бы не проверяло уже отсортированные значения - 1 потому что последнее значение не с чем сравнивать (самое большое), и что j увеличивается на 1 до тех пор пока не достигнет значения нашего массива
                {
                    if (arr[j] > arr[j + 1]) // если j больше j + 1 тоесть если какое-то значение в массиве больше следующего значения в массиве. Например второе значение в массиве 54 больше третьего значения в массиве 37 - да, тогда заходим во внутрь, если значение j меньше значения j + 1 то тогда пропускаем и увеличиваем j на 1 и опять проверяем
                    {
                        var temp = arr[j]; // в переменную temp записываем переменную j с значением например 15 в массиве
                        arr[j] = arr[j + 1]; // мы пишем что переменная j в которой хранится значение (15) равна переменной j + 1 в которой хранится значение (12) перезаписываем j и теперь она равна переменной j + 1 в которой хранится значение (12)
                        arr[j + 1] = temp; // теперь тут мы пишем что j + 1 (12) равна temp а в переменной temp хранится значение j (15) соответсвенно перезаписываем значение перемнной temp в переменную j + 1 и теперь j + 1 равна (15) 
                        swaped = true; // здесь true потому что мы вошли во внутренней цикл и какое-то значение было больше следующего значения в массиве
                    }
                }

                if (!swaped) // если не произошло изменение во внутреннем цикле и соотвественно переменная swaped так и осталась false
                {
                    break; // прекращает раньше времени внешний цикл, cортировка заканчивается немного раньше 
                }
            }

            // эта оптимизация срабатывает всегда на один раз больше так как условно мы вошли во внутрений цикл 20 раз и на 20-ом разе она поменяла местами значения и массив выглядит уже отсортированым но так как на 20-ом разе произошли изменения она думает что массив еще не отсортирован, входит 21 раз и проверяет отсортирован ли массив окончательно
            // не всегда эта оптимизация сильна помогает например если в массиве огромное количество значений то такая оптимизация будет не особа полезна но не бесполезна

            Console.WriteLine($"BubbleSortOptimized: Количество срабатываний: {counter}"); // показывает сколько было итераций внешнего цикла
        }
        public static void Main()
        {
            Console.OutputEncoding = Encoding.UTF8;
            try
            {
                Console.WriteLine($"Task Launch: Press: {(char)MenuItem.Task}");
                var menuSelect = (char)Console.Read();
                var currentSelect = (MenuItem)menuSelect;

                if (menuSelect != ((char)MenuItem.Task))
                {
                    throw new Exception("Ошибка! Введен не правильный символ!");
                }

                switch (currentSelect)
                {
                    case MenuItem.Task:

                        const int myArrSize = 30;
                        var myArr = GenerateRandomNumberArr(myArrSize);
                        //BubbleSortSimple(myArr);
                        //ShowArr(myArr);
                        BubbleSortOptimized(myArr);
                        ShowArr(myArr);
                        break;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
        }
    }
}